#[macro_use]
extern crate serde_derive;
use std::collections::HashMap;
use actix_web::{middleware, web, App, Error as AWError, HttpResponse, HttpServer, Result};
use actix_web::http::header;
use actix_web::rt::task::spawn_blocking;
//use askama::filters::format;
use askama::Template;
use r2d2_sqlite::{self, SqliteConnectionManager};

mod db;
use db::{Pool, Queries};

use oauth2::{AuthorizationCode, AuthUrl, ClientId, ClientSecret, CsrfToken, RedirectUrl, TokenResponse, TokenUrl};
use oauth2::basic::BasicClient;
use oauth2::reqwest::http_client;
//use oauth2::reqwest::http_client;
//use url::Url;

struct AppState {
    oauth: BasicClient,
}

#[derive(Template)]
#[template(path = "user.html")]
struct UserTemplate<'a> {
    name: &'a str,
    text: &'a str,
}

#[derive(Template)]
#[template(path = "index.html")]
struct Index;

async fn index(query: web::Query<HashMap<String, String>>) -> Result<HttpResponse> {
    let s = if let Some(name) = query.get("name") {
        UserTemplate {
            name,
            text: "Welcome!",
        }
            .render()
            .unwrap()
    } else {
        Index.render().unwrap()
    };
    println!("**** query={:?}", query);
    Ok(HttpResponse::Ok().content_type("text/html").body(s))
}

async fn token_count(db: web::Data<Pool>) -> Result<HttpResponse, AWError> {
    let result = db::execute(&db, Queries::GetTokenCount).await?;
    Ok(HttpResponse::Ok().json(result))
}

async fn login() -> Result<HttpResponse, AWError> {
    let auth_url = AuthUrl::new("https://accounts.secure.freee.co.jp/public_api/authorize".to_string())
        .expect("Invalid authorization endpoint URL");

    let redirect_url = RedirectUrl::new("http://localhost:8080/auth_callback".to_string())
        .expect("Invalid redirect URL");

    let client =
        BasicClient::new(
            ClientId::new("2543bdfb265b66f9b49be28b26a036c27786433b062310bd82e25472c7cfc897".to_string()),
            Some(ClientSecret::new("237c1b6c4884bdac396900ce7a3b9c902c9daa2b817d7350e41b7427324d067e".to_string())),
            auth_url,
            //Some(TokenUrl::new("https://accounts.secure.freee.co.jp/public_api/token".to_string())?)
            None
        )
            // Set the URL the user will be redirected to after the authorization process.
            .set_redirect_uri(redirect_url);

    //let (pkce_challenge, pkce_verifier) = PkceCodeChallenge::new_random_sha256();

    let (auth_url, csrf_token) = client
        .authorize_url(CsrfToken::new_random)
        // Set the desired scopes.
        //.add_scope(Scope::new("read".to_string()))
        //.add_scope(Scope::new("write".to_string()))
        // Set the PKCE code challenge.
        //.set_pkce_challenge(pkce_challenge)
        .url();

    Ok(HttpResponse::TemporaryRedirect()
        .append_header((header::LOCATION, auth_url.to_string()))
        .finish()
    )
}

#[derive(Deserialize)]
pub struct AuthRequest {
    code: String
}

async fn auth_callback(params: web::Query<AuthRequest>) -> Result<HttpResponse, AWError> {
    let code = params.code.clone();
    let code = AuthorizationCode::new(code.to_string());

    // TODO: あとで集約する
    let auth_url = AuthUrl::new("https://accounts.secure.freee.co.jp/public_api/authorize".to_string())
        .expect("Invalid authorization endpoint URL");

    let redirect_url = RedirectUrl::new("http://localhost:8080/auth_callback".to_string())
        .expect("Invalid redirect URL");

    let token_url = TokenUrl::new("https://accounts.secure.freee.co.jp/public_api/token".to_string())
    //let token_url = TokenUrl::new("http://localhost:8080/".to_string())
        .expect("Invalid token URL");

    let client =
        BasicClient::new(
            ClientId::new("2543bdfb265b66f9b49be28b26a036c27786433b062310bd82e25472c7cfc897".to_string()),
            Some(ClientSecret::new("237c1b6c4884bdac396900ce7a3b9c902c9daa2b817d7350e41b7427324d067e".to_string())),
            auth_url,
            Some(token_url)
        )
            // Set the URL the user will be redirected to after the authorization process.
            .set_redirect_uri(redirect_url);

    println!("**********");

    let token_res = spawn_blocking({move|| client.exchange_code(code).request(http_client).unwrap()}).await;
    let token = token_res.unwrap();
    println!("*** access_token={}", token.access_token().secret());
    println!("*** refresh_token={}", token.refresh_token().unwrap().secret());

    Ok(HttpResponse::TemporaryRedirect()
        .append_header((header::LOCATION, "/token_count"))
        .finish()
    )
}

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    std::env::set_var("RUST_LOG", "actix_web=info");
    env_logger::init();

    // connect to SQLite DB
    let manager = SqliteConnectionManager::file("token.db");
    let pool = Pool::new(manager).unwrap();

    // start http server
    HttpServer::new(move || {
        App::new()
            .app_data(web::Data::new(pool.clone()))
            .wrap(middleware::Logger::default())
            .service(web::resource("/").route(web::get().to(index)))
            .service(web::resource("/login").route(web::get().to(login)))
            .service(web::resource("/auth_callback").route(web::get().to(auth_callback)))
            .service(web::resource("/token_count").route(web::get().to(token_count)))
    })
        .bind(("127.0.0.1", 8080))?
        .run()
        .await
}

